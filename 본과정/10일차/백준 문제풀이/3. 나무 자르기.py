# 백준 2805번

# 입력
# 첫 줄에 나무의 수 N과 필요한 나무 길이 M이 공백으로 구분되어 입력
# 두 번째 줄에 각 나무의 높이가 공백으로 구분되어 입력

# 출력
# 필요한 나무를 얻기 위한 벌목 높이의 최대값 출력

# 로직
# 1. 시작점은 1, 끝점은 나무 중 가장 큰 값을 기준으로 이분 탐색 진행
# 2. 이분 탐색으로 중간값(벌목 높이)을 설정하고, 나무를 벌목한 총 길이 계산
# 3. 벌목된 나무의 길이가 필요한 나무 길이 M 이상이면 높이를 올리고, 부족하면 높이를 낮춤
# 4. 최종적으로 벌목 높이의 최대값 출력

N, M = map(int, input().split())  # N: 나무의 수, M: 필요한 나무 길이 (최소)
tree = list(map(int, input().split()))  # 나무들의 높이를 리스트로 입력받음
start, end = 1, max(tree)  # 이분탐색을 위한 범위 설정 (1부터 가장 높은 나무까지)

while start <= end:  # 이분탐색을 통한 적절한 벌목 높이 탐색
    mid = (start + end) // 2  # 중간값, 즉 벌목 높이 설정
    
    log = 0  # 벌목된 나무 총합을 저장할 변수
    for i in tree:  # 모든 나무에 대해 탐색
        if i >= mid:  # 나무가 벌목 높이보다 클 때만 벌목 가능
            log += i - mid  # 벌목된 나무 길이를 log에 더함 (나무 높이 - 벌목 높이)

    # 벌목된 나무의 총합이 필요한 양 이상일 때
    if log >= M:
        start = mid + 1  # 벌목 높이를 더 높여도 되므로 start를 mid + 1로 올림
    else:
        end = mid - 1  # 벌목된 양이 부족하면 높이를 낮춰야 하므로 end를 mid - 1로 낮춤

print(end)  # 적절한 벌목 높이 출력 (end가 최종적으로 맞는 높이)

# 144340KB, 4096ms