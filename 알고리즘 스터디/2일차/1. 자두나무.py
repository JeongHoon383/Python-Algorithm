# 백준 2240번

# 입력
# 첫째 줄에 두 정수 T(자두가 떨어지는 초), W(소녀가 움직이는 횟수)가 주어진다.
# 다음 T개의 줄에는 각 순간에 자두가 떨어지는 나무의 번호가 1 또는 2

# 출력
# 첫째 줄에 자두가 받을 수 있는 자두의 최대 개수를 출력

# 로직
# 행 : 지난 초 (i)
# 열 : 사람이 움직인 횟수 (j)
# dp[i][j] : i초까지 j번 움직였을 때, 얻을 수 있는 최대 자두 수

import sys

# 자두가 떨어지는 시간 T와 이동할 수 있는 횟수 W
t, w = map(int, sys.stdin.readline().rstrip().split(" "))

# 자두가 떨어지는 나무의 번호 저장
arr = [0]
for _ in range(t):
    arr.append(int(sys.stdin.readline()))

# 2차원 DP 테이블 초기화
dp = [[0] * (w+1) for _ in range(t+1)]

for i in range(t+1):

    # 1번 나무에서 한 번도 움직이지 않는 경우

    # 1번 나무에서 자두가 떨어진다면
    if (arr[i] == 1):
        dp[i][0] = dp[i-1][0] + 1

    # 2번 나무에서 자두가 떨어진다면
    else:
        dp[i][0] = dp[i-1][0]

    # 1번 이상 움직이는 경우에 대해 탐색
    for j in range(1, w+1):

        # i초에 2번 나무에서 자두가 떨어지고, 현재 2번 나무에 위치해있다면 -> 1번 움직여야 2번으로 갈 수 있기 때문
        if (arr[i] == 2 and j % 2 == 1):
            # 이전 위치로부터 움직여서 받아 먹을 것인지, 현재 위치(2번, 1번 움직인 상황)에서 받아 먹을 것인지를 비교
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + 1

        # i초에 1번 나무에서 자두가 떨어지고, 현재 1번 나무에 위치해있다면
        elif (arr[i] == 1 and j % 2 == 0):
            # 이전 위치로부터 움직여서 받아 먹을 것인지, 현재 위치에서 받아 먹을 것인지를 비교
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + 1

        # i초에 자두가 떨어지는 나무와 현재 나무의 위치가 다르다면
        else:
            # 움직여서 못 먹는 경우와 움직이지 않아서 못 먹는 경우를 비교
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j])

# DP 테이블의 마지막 행의 최댓값을 출력
print(max(dp[t]))

# 31120KB, 36ms


# 내 풀이
# 로직
# 소녀는 1번 나무에서 시작, 소녀의 나무 위치를 나타내는 변수
# 자두를 받는다 -> 소녀의 위치와 떨어지는 나무 위치가 맞을때 
# 소녀가 자두를 받았을 때 cnt += 1
# 소녀가 움직이는 횟수만큼 움직일 수 있음
# 자두를 받는 모든 경우의 수 중 최대 구하기 -> heapq?
# 자두를 받는 모든 경우의 수를 구하는 로직 모르겠음

# from sys import stdin
# input = stdin.readline

# T, W = map(int, input().split()) # 7 2
# cnt = 0 # 소녀가 받은 자두 개수
# girl = 1 # 소녀의 초기 나무 위치

# for _ in range(T):
#   tree = int(input()) # 자두가 떨어지는 나무의 번호
#   if(tree == girl):
#     cnt += 1
#   else : 
#     girl = 2
#     W -= 1
#     if(W == 0):
#       # 움직이지 못함, if 조건만 실행하게