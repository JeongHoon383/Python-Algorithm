# 입력
# 첫째 줄에 탑의 수를 나타내는 정수 N
# 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다

# 출력
# 첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력

# 로직
# 스택 사용 이유: 탑들이 레이저를 쏘면 그 레이저는 자신의 왼쪽에 있는 탑 중 하나에 닿음. 그래서 왼쪽에 있는 탑들을 효율적으로 비교하기 위해 스택을 사용한다. 스택에는 현재 비교할 탑들의 인덱스와 높이를 저장한다. 

# 스택에서의 처리: 현재 탑이 왼쪽의 탑보다 낮으면, 그 왼쪽 탑의 레이저는 현재 탑에 닿지 않으므로 스택에서 제거. 이 과정을 반복하여 스택에 남은 탑은 항상 현재 탑보다 높은 탑만 남음

# 탑이 레이저를 받는 탑 찾기: 스택에 있는 탑의 높이가 현재 탑보다 높으면, 그 탑이 레이저를 받는다는 의미이므로 해당 탑의 인덱스를 answer 배열에 기록

# 결과 출력: 모든 탑에 대해 계산을 마치면, answer 배열을 공백으로 구분하여 출력

n = int(input())  
# 탑의 개수를 입력받습니다. 예를 들어 n이 5이면 탑이 5개 있다는 뜻입니다.

top = list(map(int, input().split()))  
# 각 탑의 높이를 공백으로 구분하여 입력받아 리스트로 저장합니다. 예를 들어 [6, 9, 5, 7, 4] 같은 배열을 받습니다.

stack = []  
# 스택을 초기화합니다. 스택에는 (탑의 인덱스, 탑의 높이) 형식의 데이터를 저장하여 나중에 레이저 수신 여부를 판단합니다.

answer = [0 for i in range(n)]  
# 결과를 저장할 배열을 초기화합니다. 각 탑이 레이저를 수신하는 탑의 인덱스를 저장하는데, 인덱스는 1부터 시작하므로 기본값은 0으로 설정합니다.

for i in range(n):  
    # 각 탑에 대해 반복문을 실행합니다. i는 현재 탑의 인덱스를 나타냅니다.
    
    while stack:  
        # 스택이 비어 있지 않은 동안, 즉 비교할 이전 탑이 있을 때까지 반복합니다.
        
        if stack[-1][1] > top[i]:  
            # 스택의 맨 위에 있는 탑의 높이(stack[-1][1])가 현재 탑의 높이(top[i])보다 크면,
            # 현재 탑이 쏜 레이저가 스택의 탑에 닿은 것이므로 해당 탑의 인덱스를 기록합니다.
            
            answer[i] = stack[-1][0] + 1  
            # 스택에 있는 탑의 인덱스는 0부터 시작하므로, 1을 더하여 1-based index로 변환해 기록합니다.
            
            break  
            # 레이저가 닿은 탑을 찾았으므로 더 이상 비교할 필요가 없어 반복문을 종료합니다.
            
        else:  
            stack.pop()  
            # 현재 탑보다 작은 탑은 레이저에 가려지므로, 스택에서 제거합니다.
    
    stack.append([i, top[i]])  
    # 현재 탑의 인덱스와 높이를 스택에 추가하여 다음 탑과의 비교를 준비합니다.

print(*answer)  
# 결과 배열을 공백으로 구분하여 출력합니다.