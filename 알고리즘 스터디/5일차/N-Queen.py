# 입력
# 첫째줄에 N이 주어짐

# 출력
# 첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력

# 로직
# 1. 사용된 배열
# used_c: 각 열에 퀸이 놓여 있는지를 확인하는 배열입니다. 특정 열에 퀸이 놓여 있으면 True, 그렇지 않으면 False입니다.
# used_up: 우상향 대각선(y = x)에 퀸이 놓여 있는지를 확인하는 배열입니다. 체스판의 모든 대각선을 고려해야 하므로 길이는 2 * (n - 1) + 1로 설정됩니다.
# used_down: 우하향 대각선(y = -x)에 퀸이 놓여 있는지를 확인하는 배열입니다. 이 배열도 대각선을 고려해 동일한 길이로 설정됩니다.

# 2. 재귀 함수 sol(k)
# k는 현재까지 놓은 퀸의 개수이며, 동시에 퀸을 놓을 행을 나타냅니다.
# 함수는 현재 행에 퀸을 놓을 수 있는 모든 열을 검사합니다.
# 퀸을 놓을 수 있는지 확인한 후, 퀸을 놓고 다음 행에 대해 재귀적으로 호출합니다.
# 재귀 호출 이후에는 백트래킹을 위해 퀸을 제거하여 이전 상태로 되돌립니다.

# 3. 백트래킹의 핵심
# 백트래킹은 해를 찾는 도중에 유망하지 않은 경우 더 이상 진행하지 않고 되돌아가는 기법입니다.
# 이 코드에서는 퀸을 놓을 수 있는 위치만 탐색하여 가능한 해의 수를 효율적으로 구합니다.

## method
# N-Queen 문제를 해결하는 재귀 함수 정의
def sol(k): # k : 놓은 말 개수 - 점유 행 번호로도 활용 가능
    # 퀸 : 상하좌우 - x, y 좌표 확인 / 대각선 - (y=x 선상 : used_up) r+c 같으면. (y=-x 선상 : used_down) r-c 같으면 놓을 수 없음.
    global n, cnt  # n: 체스판 크기, cnt: 해의 개수
    
    # 종료 조건: 모든 행에 퀸을 놓았을 경우 해의 개수를 증가시킴
    if k == n :
        cnt += 1
        return

    # i : 점유 열 번호로 활용 가능
    for i in range(n):
        # 현재 열(i), 두 대각선(used_up, used_down) 모두 퀸을 놓을 수 있는지 검사
        if not used_c[i] and not used_up[k+i] and not used_down[(n-1)+k-i]:
            # 퀸을 놓았다는 표시 (열, 두 대각선 모두 점유 상태로 변경)
            used_c[i] = True
            used_up[k+i] = True
            used_down[(n-1)+k-i] = True
            # 다음 행에 퀸을 놓기 위해 재귀 호출
            sol(k+1)
            # 백트래킹: 이전 상태로 되돌리기 (퀸을 다시 제거)
            used_c[i] = False
            used_up[k+i] = False
            used_down[(n-1)+k-i] = False

## input
n = int(input())  # 체스판의 크기 n 입력 받기
maps = [[0]*n for _ in range(n)]  # n x n 크기의 체스판 초기화 (사용되지는 않음)

# 열 점유 여부 확인 배열 (각 열에 퀸이 놓여 있는지 여부 확인)
used_c = [False]*n
# y = x 대각선 점유 여부 확인 배열 (우상향 대각선 점유 여부 확인)
used_up = [False]*(2*(n-1)+1)
# y = -x 대각선 점유 여부 확인 배열 (우하향 대각선 점유 여부 확인)
used_down = [False]*(2*(n-1)+1)

cnt = 0  # 가능한 해의 개수를 저장할 변수 초기화

## output
sol(0)  # 첫 번째 행부터 시작하여 퀸을 놓기 시작
print(cnt)  # 가능한 해의 개수 출력